input {
    beats {
        id => "dynamicbeatInput"
        port => 5454
        ssl => true
        ssl_certificate => "/usr/share/logstash/config/certificates/logstash/logstash.crt"
        ssl_certificate_authorities => ["/usr/share/logstash/config/certificates/ca.crt"]
        ssl_key => "/usr/share/logstash/config/certificates/logstash/logstash.key.pkcs8"
        ssl_verify_mode => "force_peer"
    }
}

filter {
    prune {
        id => "mutateRemoveExtraFields"
        whitelist_names => ["@timestamp", "group", "id", "message", "name", "passed", "type", "score_weight", "details"]
    }
    if [passed] {
        mutate {
            add_field => {"[passed_int]" => "1"}
        }
    } else {
        mutate {
            add_field => {"[passed_int]" => "0"}
        }
    }
    mutate {
        convert => {"passed_int" => "integer"}
    }
    clone {
        id => "cloneCheck"
        clones => ["dynamicbeat"]
        add_tag => ["generic"]
        remove_field => ["message", "details"]
    }
    if "generic" in [tags] {
        mutate {
            id => "mutateClonedCheck"
            add_field => {"[@metadata][target_index]" => "results-all-%{+YYYY.MM.dd}"}
        }
    } else {
        mutate {
            id => "mutateOriginalCheck"
            add_field => {"[@metadata][target_index]" => "results-%{[group]}-%{+YYYY.MM.dd}"}
        }
    }
}

output {
    elasticsearch {
        id => "elasticsearchOutput"
        user => "logstash_internal"
        password => "${ELASTICSEARCH_PASSWORD}"
        cacert => "/usr/share/logstash/config/certificates/ca.crt"
        hosts => "${ELASTICSEARCH_HOSTS}"
        ssl => true
        index => "%{[@metadata][target_index]}"
    }
}